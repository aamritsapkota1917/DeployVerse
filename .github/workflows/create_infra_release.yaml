name: Create Terraform Release

permissions:
    contents: write

on:
    push:
        branches:
            - main
        paths:
            - "Infrastructure/terraform/**"

env:
    TF_VERSION: "1.12.2"
    WORKING_DIR: "Infrastructure/terraform"

jobs:
    create-release:
        runs-on: ubuntu-latest
        outputs:
            new_version: ${{ steps.semver.outputs.new_version }}
            version_bumped: ${{ steps.semver.outputs.version_bumped }}
        steps:
            - uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Get Latest Tag
              id: get-latest-tag
              run: |
                  # Get the latest tag for Infrastructure releases, or use infra-v0.0.0 if no tags exist
                  LATEST_TAG=$(git tag -l "infra-v*" --sort=-v:refname | head -n 1)
                  if [ -z "$LATEST_TAG" ]; then
                    LATEST_TAG="infra-v0.0.0"
                  fi
                  echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
                  echo "Latest Infrastructure tag: $LATEST_TAG"

            - name: Determine Version Bump
              id: semver
              run: |
                  LATEST_TAG="${{ steps.get-latest-tag.outputs.latest_tag }}"

                  # Remove 'infra-v' prefix for version manipulation
                  CURRENT_VERSION=${LATEST_TAG#infra-v}

                  # Split version into major.minor.patch
                  IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

                  # Get commits since last tag for Infrastructure/terraform directory only
                  if [ "$LATEST_TAG" == "infra-v0.0.0" ]; then
                    COMMITS=$(git log --pretty=format:"%s" HEAD -- Infrastructure/terraform/)
                  else
                    COMMITS=$(git log --pretty=format:"%s" ${LATEST_TAG}..HEAD -- Infrastructure/terraform/)
                  fi

                  echo "Infrastructure commits since last release:"
                  echo "$COMMITS"

                  # Check for version bump type
                  BREAKING=false
                  FEATURE=false
                  FIX=false

                  while IFS= read -r commit; do
                    if echo "$commit" | grep -qiE "^feat(\(.+\))?!:|^fix(\(.+\))?!:|BREAKING CHANGE:"; then
                      BREAKING=true
                    elif echo "$commit" | grep -qiE "^feat(\(.+\))?:"; then
                      FEATURE=true
                    elif echo "$commit" | grep -qiE "^fix(\(.+\))?:"; then
                      FIX=true
                    fi
                  done <<< "$COMMITS"

                  # Determine version bump
                  if [ "$BREAKING" = true ]; then
                    MAJOR=$((MAJOR + 1))
                    MINOR=0
                    PATCH=0
                    BUMP_TYPE="major"
                  elif [ "$FEATURE" = true ]; then
                    MINOR=$((MINOR + 1))
                    PATCH=0
                    BUMP_TYPE="minor"
                  elif [ "$FIX" = true ]; then
                    PATCH=$((PATCH + 1))
                    BUMP_TYPE="patch"
                  else
                    echo "No version bump needed (no feat/fix commits for Infrastructure)"
                    echo "version_bumped=false" >> $GITHUB_OUTPUT
                    exit 0
                  fi

                  NEW_VERSION="infra-v${MAJOR}.${MINOR}.${PATCH}"

                  echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
                  echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
                  echo "version_bumped=true" >> $GITHUB_OUTPUT

                  echo "Version bump: $LATEST_TAG â†’ $NEW_VERSION ($BUMP_TYPE)"

                  # Generate changelog
                  CHANGELOG="## Infrastructure Changes\n\n"

                  # Breaking changes
                  BREAKING_COMMITS=$(echo "$COMMITS" | grep -iE "^feat(\(.+\))?!:|^fix(\(.+\))?!:|BREAKING CHANGE:" || true)
                  if [ -n "$BREAKING_COMMITS" ]; then
                    CHANGELOG="${CHANGELOG}### BREAKING CHANGES\n"
                    while IFS= read -r commit; do
                      if [ -n "$commit" ]; then
                        CHANGELOG="${CHANGELOG}- ${commit}\n"
                      fi
                    done <<< "$BREAKING_COMMITS"
                    CHANGELOG="${CHANGELOG}\n"
                  fi

                  # Features
                  FEATURE_COMMITS=$(echo "$COMMITS" | grep -iE "^feat(\(.+\))?:" | grep -viE "^feat(\(.+\))?!:" || true)
                  if [ -n "$FEATURE_COMMITS" ]; then
                    CHANGELOG="${CHANGELOG}### New Resources/Features\n"
                    while IFS= read -r commit; do
                      if [ -n "$commit" ]; then
                        CHANGELOG="${CHANGELOG}- ${commit}\n"
                      fi
                    done <<< "$FEATURE_COMMITS"
                    CHANGELOG="${CHANGELOG}\n"
                  fi

                  # Bug fixes
                  FIX_COMMITS=$(echo "$COMMITS" | grep -iE "^fix(\(.+\))?:" | grep -viE "^fix(\(.+\))?!:" || true)
                  if [ -n "$FIX_COMMITS" ]; then
                    CHANGELOG="${CHANGELOG}### Configuration Fixes\n"
                    while IFS= read -r commit; do
                      if [ -n "$commit" ]; then
                        CHANGELOG="${CHANGELOG}- ${commit}\n"
                      fi
                    done <<< "$FIX_COMMITS"
                    CHANGELOG="${CHANGELOG}\n"
                  fi

                  # Other changes
                  OTHER_COMMITS=$(echo "$COMMITS" | grep -viE "^feat(\(.+\))?:|^fix(\(.+\))?:" || true)
                  if [ -n "$OTHER_COMMITS" ]; then
                    CHANGELOG="${CHANGELOG}###  Other Changes\n"
                    while IFS= read -r commit; do
                      if [ -n "$commit" ]; then
                        CHANGELOG="${CHANGELOG}- ${commit}\n"
                      fi
                    done <<< "$OTHER_COMMITS"
                  fi

                  # Save changelog to file
                  echo -e "$CHANGELOG" > changelog.md
                  echo "changelog_file=changelog.md" >> $GITHUB_OUTPUT

            - name: Create Git Tag
              if: steps.semver.outputs.version_bumped == 'true'
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"
                  git tag -a ${{ steps.semver.outputs.new_version }} -m "Infrastructure Release ${{ steps.semver.outputs.new_version }}"
                  git push origin ${{ steps.semver.outputs.new_version }}

            - name: Configure AWS Credentials
              if: steps.semver.outputs.version_bumped == 'true'
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ap-south-1

            - name: Package Infra release (zip)
              if: steps.semver.outputs.version_bumped == 'true'
              run: |
                  VERSION=${{ steps.semver.outputs.new_version }}
                  ZIP_NAME="${VERSION}.zip"

                  cd Infrastructure/terraform
                  zip -r "../${ZIP_NAME}" . \
                    -x ".terraform/*" \
                    -x ".git/*"
                  cd ../..

                  echo "ZIP_NAME=${ZIP_NAME}" >> $GITHUB_ENV

            - name: Upload ZIP to S3
              if: steps.semver.outputs.version_bumped == 'true'
              run: |
                  VERSION=${{ steps.semver.outputs.new_version }}
                  S3_BUCKET="${{ secrets.TERRAFORM_BUCKET_NAME }}"
                  RELEASE_PATH="releases/$VERSION"
                  ls -al

                  aws s3 cp "$ZIP_NAME" "s3://$S3_BUCKET/$RELEASE_PATH/$ZIP_NAME"

                  echo "s3://$S3_BUCKET/$RELEASE_PATH/$ZIP_NAME"
